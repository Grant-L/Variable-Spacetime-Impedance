\chapter{Simulation Code Repository}
\label{app:code_repo}

\section{C.1 Introduction}
All scripts utilize FDTD and Ginzburg-Landau methods based on the global constants defined in \texttt{src/constants.py}. [cite: 859]

\section{C.2 Core Code: Metric Lensing}
\begin{lstlisting}[language=Python, caption=Gravitational Lensing Simulation]
import numpy as np

def run_metric_simulation(Nx=600, Ny=400, Nt=1200):
    u = np.zeros((Nx, Ny))
    u_prev = np.zeros((Nx, Ny))
    
    # Grid for metric strain mapping
    X, Y = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')
    R = np.sqrt((X - Nx//2)**2 + (Y - (Ny//2+50))**2)
    
    # n = 1 + epsilon (refractive index gradient)
    n_map = 1.0 + 20.0 / (np.sqrt(R**2 + 10.0)) 
    v_map = 1.0 / n_map # Local phase velocity
    
    dt = 0.5
    for t in range(Nt):
        lap = (np.roll(u, 1, 0) + np.roll(u, -1, 0) + 
               np.roll(u, 1, 1) + np.roll(u, -1, 1) - 4*u)
        u_next = 2*u - u_prev + (v_map * dt)**2 * lap
        
        if t < 100: 
            u_next[5, Ny//2-50] += np.sin(0.6*t)
            
        u_prev, u = u.copy(), u_next.copy()
    return u
\end{lstlisting}

\section{C.3 Core Code: The Cosmic Quench}
\begin{lstlisting}[language=Python, caption=Vacuum Phase Transition (Genesis)]
def simulate_quench(N=300, steps=1500):
    # Initial Hot Disordered Phase
    psi = np.exp(1j * np.random.uniform(-np.pi, np.pi, (N, N)))
    dt, dx = 0.001, 0.1
    
    for t in range(steps):
        lap = (np.roll(psi, 1, 0) + np.roll(psi, -1, 0) + 
               np.roll(psi, 1, 1) + np.roll(psi, -1, 1) - 4*psi) / (dx**2)
        # GL Relaxation to ordered state
        psi += dt * (lap + psi * (1.0 - np.abs(psi)**2))
    return np.angle(psi)
\end{lstlisting}

\section*{C.4 Quantum Layer: Pilot Wave Walkers}
\begin{lstlisting}[language=Python, caption=Simulating the Pilot Wave Feedback Loop]
# sim_3_pilot_wave_v2.py
def run_pilot_wave_walker_v2(Nx=300, Ny=200, Nt=2000):
    u = np.zeros((Nx, Ny)) # Memory Field
    xp, yp = Nx // 4, Ny // 2 # Walker Position
    
    for t in range(Nt):
        # 1. Update Vacuum Wave Equation
        lap = get_laplacian(u)
        u_next = 2*u - u_prev + (c*dt)**2 * lap
        
        # 2. Walker "Surfs" the Gradient
        grad_x, grad_y = np.gradient(u)
        xp += coupling * grad_x[int(xp), int(yp)]
        yp += coupling * grad_y[int(xp), int(yp)]
        
        # 3. Walker Impacts Lattice (Source Term)
        u_next[int(xp), int(yp)] += np.sin(omega * t)
\end{lstlisting}

\section*{C.5 Topological Layer: The Proton Triplet}
\begin{lstlisting}[language=Python, caption=Ginzburg-Landau Relaxation of Quark Knots]
# sim_4_proton_triplet_final.py
def run_proton_topology():
    # Initialize 3 Phase Singularities (Quarks)
    psi = initialize_vortices(poles=[(100,100), (120,135), (80,135)])
    
    for t in range(relaxation_steps):
        # GL Equation minimizes free energy
        # The phase gradients form "Flux Tubes" (Gluons)
        psi += dt * (laplacian(psi) + psi * (1 - abs(psi)**2))
    
    plot_phase_and_density(psi) # Visualizes the Trefoil Knot
\end{lstlisting}

\section*{C.6 Weak Layer: Impedance Clamping}
\begin{lstlisting}[language=Python, caption=Chiral Filter Simulation]
# sim_5_weak_clamping.py
def run_weak_clamping_sim():
    # Define High-Impedance Region for Right-Handed Chirality
    Z_map = np.ones((Nx, Ny))
    Z_map[filter_zone] = 1000.0 # "Clamping" Zone
    
    # Propagate Helical Pulse
    # Left-Handed (Low Z) -> Passes
    # Right-Handed (High Z) -> Reflects (Parity Violation)
    u_next = update_wave_equation_variable_Z(u, Z_map)
\end{lstlisting}

\section*{C.7 Cosmological Layer: The Hubble Pulse}
\begin{lstlisting}[language=Python, caption=Dark Energy as Latent Heat Release]
# sim_6_cosmological_expansion.py
def run_cosmic_pulse():
    t = np.linspace(0, 14, 1000) # Billions of Years
    rho_matter = 1.0 / t**3
    
    # Latent Heat Release (Sigmoid Function)
    rho_vacuum = 0.7 / (1 + np.exp(-(t - t_transition)))
    
    # Friedman Equation with Variable Vacuum Energy
    H = np.sqrt(rho_matter + rho_vacuum)
    plot(t, H) # Shows the "Jerk" at t_transition
\end{lstlisting}

\section*{C.8 Galactic Layer: Abrikosov Stiffness}
\begin{lstlisting}[language=Python, caption=Galaxy Rotation with Vacuum Tension]
# sim_7_galactic_rotation_v2.py
def run_galactic_rotation():
    r = np.linspace(0, 50, 500)
    v_newton = np.sqrt(M / r) # Decays
    
    # LCT: Vacuum acts as a stiff superfluid
    # Stiffness k increases with radius (Vortex Density)
    v_vacuum = stiffness * r 
    
    # Total Velocity = Sqrt(Newton^2 + Vacuum^2)
    v_total = np.sqrt(v_newton**2 + v_vacuum**2)
    plot(r, v_total) # Result: Flat Rotation Curve
\end{lstlisting}

\section*{C.9 Engineering Layer: Casimir Filter}
\begin{lstlisting}[language=Python, caption=High-Pass Filtering in a Cavity]
# sim_8_casimir_filter.py
def run_casimir_filter():
    # Set Dirichlet BCs at plates (Distance d)
    u[plate_1] = 0; u[plate_2] = 0
    
    # Inject White Noise
    noise = gaussian_noise()
    
    # Measure Spectral Density inside vs outside
    # Result: Frequencies < c/2d are suppressed
    plot_spectrum(signal_inside, signal_outside)
\end{lstlisting}