\chapter{Appendix D: Computational Verification Suite}

\section{Simulation: Gravitational Lensing (Refraction)}
\begin{lstlisting}[language=Python]
import numpy as np
def simulate_lensing():
    Nx, Ny = 600, 400; Nt = 1200; dt = 0.5
    x = np.arange(Nx); y = np.arange(Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')
    R = np.sqrt((X - Nx//2)**2 + (Y - (Ny//2+50))**2)
    n_map = 1.0 + 20.0 / (np.sqrt(R**2 + 10.0)) 
    v_map = 1.0 / n_map 
    u = np.zeros((Nx, Ny)); u_prev = np.zeros((Nx, Ny))
    for t in range(Nt):
        lap = (np.roll(u,1,0) + np.roll(u,-1,0) + 
               np.roll(u,1,1) + np.roll(u,-1,1) - 4*u)
        u_next = 2*u - u_prev + (v_map * dt)**2 * lap
        if t < 100: u_next[5, Ny//2-50] += np.sin(0.6*t)
        u_prev, u = u, u_next
    return u
\end{lstlisting}

\section{Simulation: The Quantum Walker (Double Slit)}
\begin{lstlisting}[language=Python]
% [Insert your Quantum Walker code here]
\end{lstlisting}

\section{Simulation: The Genesis (Crystallization)}
\begin{lstlisting}[language=Python]
def simulate_genesis():
    Nx, Ny = 200, 200; dt = 0.2
    psi = (np.random.rand(Nx, Ny)-0.5) + 1j*(np.random.rand(Nx, Ny)-0.5)
    psi /= np.abs(psi)
    for t in range(800):
        lap = (np.roll(psi,1,0)+np.roll(psi,-1,0)+np.roll(psi,1,1)+np.roll(psi,-1,1)-4*psi)
        psi += dt**2 * (lap + psi*(1-np.abs(psi)**2)) - 0.1*psi
    return np.abs(psi)**2
\end{lstlisting}

\section{Simulation: The Entanglement Bridge}
\begin{lstlisting}[language=Python]
% [Insert your Entanglement Bridge code here]
\end{lstlisting}