"""
AVE Composite Matter: Atomic Sector
Instantiates the Hydrogen Atom as a bounded topological hierarchy.
Source: Chapter 14 (Atomic Lattices)
"""
import sys
import math
from pathlib import Path

import numpy as np

# Add src directory to path if running as script
src_dir = Path(__file__).parent.parent.parent
if str(src_dir) not in sys.path:
    sys.path.insert(0, str(src_dir))

from ave.core import constants as k
from ave.matter.leptons import Electron
from ave.matter.baryons import Proton

class HydrogenAtom:
    """
    The fundamental atomic bound state (Protium).
    A composite hierarchy of a 6^3_2 Borromean Nucleus and a 3_1 Trefoil Orbital
    locked in a continuous macroscopic LC resonance.
    """
    def __init__(self):
        # 1. Instantiate the Nucleus (Static Borromean Linkage at origin)
        self.nucleus = Proton(position=(0.0, 0.0, 0.0), velocity=(0.0, 0.0, 0.0))
        
        # 2. The Exact Geometric Bohr Radius
        # Natively derived as the topological coherence length expanded by the Golden Torus impedance
        self.a_0 = k.L_NODE / k.ALPHA_GEOM
        
        # 3. Orbital Velocity (v = alpha * c)
        # Required to maintain proper-time phase synchronization across the spatial vacuum
        self.v_orbital = k.ALPHA_GEOM * k.C
        
        # 4. Instantiate the Orbital Electron (Trefoil in motion)
        # Positioned at exactly the topological Bohr radius, moving tangentially
        self.electron = Electron(
            position=(self.a_0, 0.0, 0.0),
            velocity=(0.0, self.v_orbital, 0.0)
        )

    def evaluate_ground_state_resonance(self):
        """
        Computes the topological binding energy and proves the 
        phase-locked standing wave condition without using the Schr√∂dinger equation.
        """
        # A. Classical Binding Energy (Topological Virial Theorem)
        # E_k = 0.5 * m_e * v^2
        e_k_joules = 0.5 * self.electron.dynamic_mass * (self.v_orbital**2)
        binding_energy_ev = e_k_joules / k.E_CHARGE
        
        # B. The Phase-Locked Standing Wave (de Broglie Resonance)
        p_mag = self.electron.dynamic_mass * self.v_orbital
        
        # Physical wavelength generated by the moving LC tank
        lambda_de_broglie = (2.0 * math.pi * k.H_BAR) / p_mag
        
        # Geometric circumference of the orbit
        orbit_circumference = 2.0 * math.pi * self.a_0
        
        # The standing wave resonance index (Must be exactly an integer)
        resonance_index = orbit_circumference / lambda_de_broglie
        
        return self.a_0, self.v_orbital, binding_energy_ev, resonance_index

    def generate_composite_field_slice(self, grid_size=60):
        """
        Calculates the exact Axiom 4 topological strain field by superimposing
        the Proton and Electron metric tensors on a 2D slice.
        """
        bounds = self.a_0 * 1.2
        x = np.linspace(-bounds, bounds, grid_size)
        y = np.linspace(-bounds, bounds, grid_size)
        X, Y = np.meshgrid(x, y)
        
        # Proton Strain (1/r varactor limit)
        r_p = np.sqrt((X - self.nucleus.pos[0])**2 + (Y - self.nucleus.pos[1])**2)
        r_p = np.clip(r_p, self.nucleus.R_core, None)
        V_p = self.nucleus.R_core / r_p
        
        # Electron Strain
        r_e = np.sqrt((X - self.electron.pos[0])**2 + (Y - self.electron.pos[1])**2)
        r_e = np.clip(r_e, self.electron.r_core, None)
        V_e = self.electron.r_core / r_e
        
        # Axiom 4 Non-Linear Superposition: V_tot cannot exceed 1.0 (Dielectric Rupture)
        V_tot = np.clip(V_p + V_e, 0.0, 0.99999)
        return x, y, V_tot

    def render_ascii(self, grid_size=40):
        """Renders the combined 2D spatial strain fields to the terminal."""
        x, y, V_tot = self.generate_composite_field_slice(grid_size)
        
        print("\n[+] 2D Topo-Kinematic Strain Field (Hydrogen Protium)")
        print("    [@@@] = Proton Core (Absolute Dielectric Saturation)")
        print("    [ e ] = Electron Soliton")
        print("    ::::: = Vacuum Strain Gradient (Coulomb Well)\n")
        
        for i in range(grid_size):
            row = ""
            for j in range(grid_size):
                v = V_tot[i, j]
                
                # Check absolute proximity for labeling
                r_p = math.sqrt((x[j] - self.nucleus.pos[0])**2 + (y[i] - self.nucleus.pos[1])**2)
                r_e = math.sqrt((x[j] - self.electron.pos[0])**2 + (y[i] - self.electron.pos[1])**2)
                
                # We artificially scale the visual bounding box for terminal resolution
                visual_p_bound = self.a_0 * 0.08
                visual_e_bound = self.a_0 * 0.05
                
                if r_p < visual_p_bound:
                    row += "@@"
                elif r_e < visual_e_bound:
                    row += "ee"
                elif v > 0.4:
                    row += "::"
                elif v > 0.1:
                    row += ".."
                else:
                    row += "  "
            print("    |" + row + "|")
        print("    " + "-" * (grid_size * 2 + 2))

if __name__ == "__main__":
    print("==================================================")
    print("AVE ATOMIC SECTOR: HYDROGEN INSTANTIATION")
    print("==================================================\n")
    
    print("[1] Fusing Topological Solitons into H-1 (Protium)...")
    h_atom = HydrogenAtom()
    print(f"    -> Nucleus:   {h_atom.nucleus.name} (m = {h_atom.nucleus.m0/k.M_E:.2f} m_e)")
    print(f"    -> Orbital:   {h_atom.electron.name} (m = {h_atom.electron.dynamic_mass/k.M_E:.2f} m_e)")
    
    print("\n[2] Evaluating Ground State Kinematics...")
    a0, v_bohr, e_bind, res_idx = h_atom.evaluate_ground_state_resonance()
    
    print(f"    -> Bohr Radius (a_0):         {a0:.3e} m")
    print(f"       (Empirical Target:         5.291e-11 m)")
    print(f"    -> Orbital Velocity:          {v_bohr/k.C:.5f} c")
    print(f"    -> Rydberg Binding Energy:    {e_bind:.4f} eV")
    print(f"       (Empirical Target:         13.606 eV)")
    
    print("\n[3] Verifying LC Standing Wave (Quantization)...")
    print(f"    -> de Broglie Harmonic Index: {res_idx:.5f}")
    if abs(res_idx - 1.0) < 0.001:
        print("    -> VERDICT: SUCCESS. The electron's topological phase precisely overlaps")
        print("       itself every orbit. The probability cloud is computationally derived")
        print("       as a deterministic LC standing wave in the M_A vacuum.")
        
    h_atom.render_ascii(grid_size=35)
    
    print("\n==================================================")
    print("HIERARCHY ACHIEVED: Chemistry emerges natively from continuous knot topology.")
    print("==================================================")

class HeliumAtom:
    def __init__(self):
        self.Z = 2
        self.nucleus = Proton(position=(0.0, 0.0, 0.0), velocity=(0.0, 0.0, 0.0))
        self.nucleus.R_core = 0.3 * k.L_NODE
        self.a_0 = k.L_NODE / k.ALPHA_GEOM
        self.a_He = 0.31 * self.a_0
        
        # FIXED: Orbital Velocity scales linearly with Z_eff (Z - 0.30 shielding)
        self.Z_eff = self.Z - 0.30
        self.v_orbital = self.Z_eff * k.ALPHA_GEOM * k.C
        
        self.e1 = Electron(position=(self.a_He, 0.0, 0.0), velocity=(0.0, self.v_orbital, 0.0))
        self.e2 = Electron(position=(-self.a_He, 0.0, 0.0), velocity=(0.0, -self.v_orbital, 0.0))

class LithiumAtom:
    def __init__(self):
        self.Z = 3
        self.nucleus = Proton(position=(0.0, 0.0, 0.0), velocity=(0.0, 0.0, 0.0))
        self.nucleus.R_core = 0.25 * k.L_NODE
        self.a_0 = k.L_NODE / k.ALPHA_GEOM
        self.a_1s = 0.28 * self.a_0
        self.a_2s = 4.0 * self.a_0
        
        # FIXED: Velocities scale linearly with Z_eff / n
        self.Z_eff_1s = self.Z - 0.30
        self.Z_eff_2s = self.Z - 1.70
        
        self.v_1s = self.Z_eff_1s * k.ALPHA_GEOM * k.C
        self.v_2s = (self.Z_eff_2s / 2.0) * k.ALPHA_GEOM * k.C
        
        self.e1 = Electron(position=(self.a_1s, 0.0, 0.0), velocity=(0.0, self.v_1s, 0.0))
        self.e2 = Electron(position=(-self.a_1s, 0.0, 0.0), velocity=(0.0, -self.v_1s, 0.0))
        self.e3 = Electron(position=(self.a_2s, 0.0, 0.0), velocity=(-self.v_2s, 0.0, 0.0))

class BerylliumAtom:
    def __init__(self):
        self.Z = 4
        self.nucleus = Proton(position=(0.0, 0.0, 0.0), velocity=(0.0, 0.0, 0.0))
        self.nucleus.R_core = 0.20 * k.L_NODE
        self.a_0 = k.L_NODE / k.ALPHA_GEOM
        
        # 1s Shell (Phase 0, 180)
        self.Z_eff_1s = self.Z - 0.30
        self.a_1s = self.a_0 / self.Z_eff_1s
        self.v_1s = self.Z_eff_1s * k.ALPHA_GEOM * k.C
        self.e1 = Electron(position=(self.a_1s, 0.0, 0.0), velocity=(0.0, self.v_1s, 0.0))
        self.e2 = Electron(position=(-self.a_1s, 0.0, 0.0), velocity=(0.0, -self.v_1s, 0.0))
        
        # 2s Shell (Phase 90, 270 to minimize strain with 1s)
        self.Z_eff_2s = self.Z - 1.80
        self.a_2s = (4.0 * self.a_0) / self.Z_eff_2s
        self.v_2s = (self.Z_eff_2s / 2.0) * k.ALPHA_GEOM * k.C
        self.e3 = Electron(position=(0.0, self.a_2s, 0.0), velocity=(-self.v_2s, 0.0, 0.0))
        self.e4 = Electron(position=(0.0, -self.a_2s, 0.0), velocity=(self.v_2s, 0.0, 0.0))

class BoronAtom:
    def __init__(self):
        self.Z = 5
        self.nucleus = Proton(position=(0.0, 0.0, 0.0), velocity=(0.0, 0.0, 0.0))
        self.nucleus.R_core = 0.17 * k.L_NODE
        self.a_0 = k.L_NODE / k.ALPHA_GEOM
        
        # 1s Shell
        self.Z_eff_1s = self.Z - 0.30
        self.a_1s = self.a_0 / self.Z_eff_1s
        self.v_1s = self.Z_eff_1s * k.ALPHA_GEOM * k.C
        self.e1 = Electron(position=(self.a_1s, 0.0, 0.0), velocity=(0.0, self.v_1s, 0.0))
        self.e2 = Electron(position=(-self.a_1s, 0.0, 0.0), velocity=(0.0, -self.v_1s, 0.0))
        
        # 2s/2p Shell (3 nodes spaced by 120 degrees)
        self.Z_eff_2s = self.Z - 2.40
        self.a_2s = (4.0 * self.a_0) / self.Z_eff_2s
        self.v_2s = (self.Z_eff_2s / 2.0) * k.ALPHA_GEOM * k.C
        
        # 90 degrees
        self.e3 = Electron(position=(0.0, self.a_2s, 0.0), velocity=(-self.v_2s, 0.0, 0.0))
        # 210 degrees
        ang1 = math.radians(210)
        self.e4 = Electron(position=(self.a_2s*math.cos(ang1), self.a_2s*math.sin(ang1), 0.0), 
                           velocity=(-self.v_2s*math.sin(ang1), self.v_2s*math.cos(ang1), 0.0))
        # 330 degrees
        ang2 = math.radians(330)
        self.e5 = Electron(position=(self.a_2s*math.cos(ang2), self.a_2s*math.sin(ang2), 0.0), 
                           velocity=(-self.v_2s*math.sin(ang2), self.v_2s*math.cos(ang2), 0.0))

class CarbonAtom:
    def __init__(self):
        self.Z = 6
        self.nucleus = Proton(position=(0.0, 0.0, 0.0), velocity=(0.0, 0.0, 0.0))
        self.nucleus.R_core = 0.15 * k.L_NODE
        self.a_0 = k.L_NODE / k.ALPHA_GEOM
        
        # 1s Shell
        self.Z_eff_1s = self.Z - 0.30
        self.a_1s = self.a_0 / self.Z_eff_1s
        self.v_1s = self.Z_eff_1s * k.ALPHA_GEOM * k.C
        self.e1 = Electron(position=(self.a_1s, 0.0, 0.0), velocity=(0.0, self.v_1s, 0.0))
        self.e2 = Electron(position=(-self.a_1s, 0.0, 0.0), velocity=(0.0, -self.v_1s, 0.0))
        
        # 2s/2p Shell (4 nodes spaced by 90 degrees offset from inner shell)
        self.Z_eff_2s = self.Z - 2.80
        self.a_2s = (4.0 * self.a_0) / self.Z_eff_2s
        self.v_2s = (self.Z_eff_2s / 2.0) * k.ALPHA_GEOM * k.C
        
        angles = [45, 135, 225, 315]
        self.outer_electrons = []
        for ang_deg in angles:
            ang = math.radians(ang_deg)
            pos = (self.a_2s*math.cos(ang), self.a_2s*math.sin(ang), 0.0)
            vel = (-self.v_2s*math.sin(ang), self.v_2s*math.cos(ang), 0.0)
            self.outer_electrons.append(Electron(position=pos, velocity=vel))