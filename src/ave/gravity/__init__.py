"""
Gravity Module: Optical Metric and Impedance Gradients
======================================================
Gravity is modeled as the macroscopic optical refraction of the LC vacuum
network. A massive topological defect polarizes the local inductance and
permittivity, creating a refractive index gradient that bends all wave
propagation (photons and massive wave-packets alike).

Key results (Ch. 9):
  - Principal radial strain:  ε₁₁(r) = 7GM/(c²r)
  - Refractive index:         n(r) = 1 + 2GM/(c²r)
  - Achromatic matching:      μ'/ε' scales symmetrically → Z₀ invariant
"""

import numpy as np
from ave.core.constants import G, C_0, Z_0, MU_0, EPSILON_0, NU_VAC


def principal_radial_strain(mass_kg: float, radius_m: float) -> float:
    """
    1D principal radial strain generated by a point mass via Laplace eqn.

    ε₁₁(r) = 7GM / (c²r)

    The factor 7 emerges from the isotropic Machian stress boundary
    T_max,g = c⁴/(7G).

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance from center of mass [m]. Must be > 0.

    Returns:
        Dimensionless radial strain.
    """
    if radius_m <= 0:
        raise ValueError("Radius must be > 0.")
    return (7.0 * G * mass_kg) / (C_0**2 * radius_m)


def refractive_index(mass_kg: float, radius_m: float) -> float:
    """
    Effective scalar refractive index of the vacuum at distance r from mass M.

    n(r) = 1 + (ν_vac) · ε₁₁(r) = 1 + 2GM/(c²r)

    where ν_vac = 2/7 is the trace-reversed Poisson ratio.

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance from center of mass [m].

    Returns:
        Scalar refractive index (≥ 1.0 always for positive mass).
    """
    if radius_m <= 0:
        raise ValueError("Radius must be > 0.")
    return 1.0 + (2.0 * G * mass_kg) / (C_0**2 * radius_m)


def is_dielectric_rupture(mass_kg: float, radius_m: float) -> bool:
    """
    Checks if local metric strain exceeds the Axiom 4 dielectric saturation
    limit (unitary strain). This defines the Event Horizon.

    Rupture when: 2GM/(c²r) ≥ 1    →   r ≤ 2GM/c² (Schwarzschild radius)

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance from center of mass [m].

    Returns:
        True if within the event horizon (dielectric rupture).
    """
    schwarzschild_r = (2.0 * G * mass_kg) / C_0**2
    return radius_m <= schwarzschild_r


def schwarzschild_radius(mass_kg: float) -> float:
    """
    The Schwarzschild radius as the dielectric rupture limit.

    R_s = 2GM/c²

    Args:
        mass_kg: Source mass [kg].

    Returns:
        Schwarzschild radius [m].
    """
    return (2.0 * G * mass_kg) / C_0**2


def local_mu(mass_kg: float, radius_m: float) -> float:
    """
    Achromatic impedance matching: local permeability scales with n(r).

    μ'(r) = n(r) · μ₀

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance [m].

    Returns:
        Local permeability [H/m].
    """
    n = refractive_index(mass_kg, radius_m)
    return n * MU_0


def local_epsilon(mass_kg: float, radius_m: float) -> float:
    """
    Achromatic impedance matching: local permittivity scales with n(r).

    ε'(r) = n(r) · ε₀

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance [m].

    Returns:
        Local permittivity [F/m].
    """
    n = refractive_index(mass_kg, radius_m)
    return n * EPSILON_0


def local_impedance(mass_kg: float, radius_m: float) -> float:
    """
    Local transverse impedance — INVARIANT under gravitational strain.

    Z'(r) = √(μ'/ε') = √(n·μ₀ / n·ε₀) = Z₀

    This achromatic matching guarantees no reflection at gravitational
    impedance boundaries (gravity acts as a perfect lens).

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance [m].

    Returns:
        Local impedance [Ω] — should always equal Z₀.
    """
    mu = local_mu(mass_kg, radius_m)
    ep = local_epsilon(mass_kg, radius_m)
    return np.sqrt(mu / ep)


def gravitational_potential(mass_kg: float, radius_m: float) -> float:
    """
    Newtonian gravitational potential as ponderomotive wave energy.

    U(r) = -GM/r

    Derived from F = -∇(m c²/n(r)) in the wave-packet limit.

    Args:
        mass_kg: Source mass [kg].
        radius_m: Distance [m].

    Returns:
        Gravitational potential [J/kg].
    """
    if radius_m <= 0:
        raise ValueError("Radius must be > 0.")
    return -G * mass_kg / radius_m


def einstein_deflection_angle(mass_kg: float, impact_parameter_m: float) -> float:
    """
    Photon deflection via the optical metric (Snell's law through n(r)).

    δ = 4GM / (bc²)

    This matches GR exactly and is DOUBLE the Newtonian corpuscular prediction.

    Args:
        mass_kg: Source mass [kg].
        impact_parameter_m: Closest approach distance [m].

    Returns:
        Deflection angle [radians].
    """
    if impact_parameter_m <= 0:
        raise ValueError("Impact parameter must be > 0.")
    return (4.0 * G * mass_kg) / (impact_parameter_m * C_0**2)
