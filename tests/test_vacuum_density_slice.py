"""
Vacuum Density Scalar Field Visualizer
--------------------------------------
Computes and visually renders a 2D slice of the macroscopic 
vacuum density (refractive strain) generated by the discrete 
topological knot lattice of a Helium-4 nucleus.
"""
import os
import numpy as np
import matplotlib.pyplot as plt

def compute_nucleon_centroids(shift_distance: float = 0.85):
    """
    Returns the exact 3D coordinates and labels for the 4 nucleons 
    in the Helium-4 tetrahedral alpha particle cluster.
    """
    return [
        {'pos': np.array([ shift_distance,  shift_distance,  shift_distance]), 'type': 'Proton',  'color': '#ff3366'},
        {'pos': np.array([-shift_distance, -shift_distance,  shift_distance]), 'type': 'Proton',  'color': '#ff3366'},
        {'pos': np.array([-shift_distance,  shift_distance, -shift_distance]), 'type': 'Neutron', 'color': '#00ffcc'},
        {'pos': np.array([ shift_distance, -shift_distance, -shift_distance]), 'type': 'Neutron', 'color': '#00ffcc'}
    ]

def plot_density_slice(z_slice: float = 0.0, output_name: str = "helium_4_density_slice.png"):
    nucleons = compute_nucleon_centroids()
    
    # Setup 2D spatial grid for the scalar evaluation
    grid_size = 300
    bound = 3.5
    x = np.linspace(-bound, bound, grid_size)
    y = np.linspace(-bound, bound, grid_size)
    X, Y = np.meshgrid(x, y)
    
    # Initialize blank density field
    density_field = np.zeros_like(X)
    
    # Sum the scalar topological strain (1/r potential approx of the Faddeev-Skyrme defect)
    # The actual defect decays smoothly to 0. Add a small epsilon to avoid divide by zero.
    epsilon = 0.2
    characteristic_radius = 1.0
    
    for n in nucleons:
        cx, cy, cz = n['pos']
        # Distance squared from each grid point to the nucleon 3D center
        r_sq = (X - cx)**2 + (Y - cy)**2 + (z_slice - cz)**2
        
        # Faddeev-Skyrme style smooth localization (Lorentzian/Gaussian hybrid)
        # Yields a central "core" density that diffuses outward.
        local_density = 1.0 / (1.0 + (r_sq / (characteristic_radius**2))**2)
        density_field += local_density

    # --- Render Configuration ---
    fig, ax = plt.subplots(figsize=(10, 8))
    fig.patch.set_facecolor('#0f0f0f')
    ax.set_facecolor('#0f0f0f')
    
    # Plot the scalar density field as a smooth continuous heatmap
    cmap = plt.cm.inferno
    cmap.set_bad(color='#0f0f0f')
    
    im = ax.imshow(density_field, extent=[-bound, bound, -bound, bound], 
                   origin='lower', cmap=cmap, alpha=0.9, vmin=0.0)
                   
    # Compute the 2D spatial gradient (metric flux/strain)
    # The topological 'gravity' points towards higher density (inward)
    grad_y, grad_x = np.gradient(density_field)
    
    # Overlay Continuous Streamlines (Topological Gravity Flux)
    # Streamplot natively handles vector normalization visually
    ax.streamplot(x, y, grad_x, grad_y, 
                  color='#aaaaaa', linewidth=1.2, density=1.5, 
                  arrowstyle='->', arrowsize=1.5)
                   
    # Overlay the Center of Mass markers
    for n in nucleons:
        cx, cy, cz = n['pos']
        # Only clearly plot the node if it's relatively close to the Z-slice being evaluated
        if abs(cz - z_slice) < 1.5:
            # Scale marker size based on depth proximity to the slice
            depth_scale = np.exp(-abs(cz - z_slice))
            
            # Draw targeting reticles
            ax.scatter(cx, cy, color=n['color'], s=500 * depth_scale, marker='+', linewidth=3, alpha=0.8)
            ax.scatter(cx, cy, color=n['color'], s=150 * depth_scale, edgecolor=n['color'], facecolor='none', linewidth=2, alpha=0.9)
            
            ax.text(cx + 0.15, cy + 0.15, f"{n['type']} CoM", color=n['color'], 
                    fontsize=12, fontweight='bold', alpha=0.9,
                    bbox=dict(facecolor='#111111', edgecolor='none', alpha=0.5, pad=1))

    # Formatting
    ax.set_title(f"Vacuum Density Mapping: Helium-4 (Slice Z={z_slice:.1f})", color='white', fontsize=16, pad=20)
    ax.set_xlabel("X (Topological Node Lengths)", color='white', fontsize=12)
    ax.set_ylabel("Y (Topological Node Lengths)", color='white', fontsize=12)
    ax.tick_params(colors='white')
    
    # Aesthetic Grid
    ax.grid(color='#ffffff', linestyle=':', alpha=0.2)
    
    # Add a colorbar to represent macroscopic mass/strain intensity
    cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
    cbar.set_label(r'Topological Density Strain ($\kappa_V$ Gradient)', color='white', fontsize=12)
    cbar.ax.yaxis.set_tick_params(color='white')
    cbar.ax.yaxis.set_tick_params(labelcolor='white')

    os.makedirs('tests/outputs', exist_ok=True)
    out_path = os.path.join('tests/outputs', output_name)
    plt.tight_layout()
    plt.savefig(out_path, dpi=300, facecolor=fig.get_facecolor())
    plt.close()
    
    print(f"[*] Saved Volumetric Density Slice: {out_path}")

if __name__ == "__main__":
    # Generate slices at different z-depths to fully capture the 3D volume mapping
    # Since they are at Z = +/- 0.85, let's take slices specifically at those depths
    plot_density_slice(z_slice=0.85, output_name="helium_4_density_z_pos.png")
    plot_density_slice(z_slice=-0.85, output_name="helium_4_density_z_neg.png")
    plot_density_slice(z_slice=0.0, output_name="helium_4_density_equator.png")
