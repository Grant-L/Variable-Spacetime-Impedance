#!/usr/bin/env python3
r"""
Double Slit Standing Wave Heatmap: JAX GPU-Accelerated FDTD
==============================================================

GPU-accelerated port of simulate_double_slit_observer.py.
All physics is IDENTICAL â€” only the compute backend changes.

In the AVE framework, a "photon" is a helical soliton propagating through
the LC lattice. The double slit experiment is NOT mysterious â€” it is a
straightforward acoustic interference problem in a structured medium.

AVE physics (manuscript Ch. 3, Â§Deterministic Interference):
  The topological defect (PARTICLE) passes through SLIT 1.
  The continuous transverse inductive WAKE generated by its motion
  radiates outward from the particle's trajectory and passes through
  BOTH slits.  The wake diffracts and interferes on the far side.
  The particle is steered by ponderomotive gradients âˆ‡|Î¨|Â² into the
  resulting standing-wave troughs.

What "observation" means physically:
  A detector at Slit 2 is a localized impedance perturbation that
  thermalizes the wake's phase energy (Joule friction), destroying
  the coherence between the two slit contributions â†’ single-slit envelope.

Usage:
    python scripts/book_1_foundations/simulate_double_slit_observer_jax.py
"""

import os
import sys
import numpy as np
import jax
import jax.numpy as jnp
from jax import jit, lax

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'src'))

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec

OUT_DIR = os.path.join(os.path.dirname(__file__), '..', '..', 'assets', 'sim_outputs')
os.makedirs(OUT_DIR, exist_ok=True)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# JAX-Accelerated 2D FDTD Acoustic Solver
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _build_sponge(nx, ny, sponge=50):
    """Build sponge absorbing boundary layer (computed once on CPU)."""
    d = np.ones((nx, ny))
    for i in range(sponge):
        factor = 1.0 - 0.06 * ((sponge - i) / sponge) ** 2
        d[i, :] *= factor
        d[nx - 1 - i, :] *= factor
        d[:, i] *= factor
        d[:, ny - 1 - i] *= factor
    return jnp.array(d)


def _build_wall(nx, ny, wall_x, wall_t, slit_w, slit_1, slit_2):
    """Build wall mask with two slits (computed once on CPU)."""
    mask = np.zeros((nx, ny), dtype=bool)
    mask[wall_x:wall_x + wall_t, :] = True
    mask[wall_x:wall_x + wall_t, slit_1 - slit_w//2:slit_1 + slit_w//2] = False
    mask[wall_x:wall_x + wall_t, slit_2 - slit_w//2:slit_2 + slit_w//2] = False
    return jnp.array(mask)


def _build_obs_damping(nx, ny, wall_x, slit_2, slit_w, observe_slit):
    """Build Ohmic damping mask at slit 2.
    AVE first principles: observer = resistive load that thermalizes
    the wake's phase energy (Joule friction: W âˆ |âˆ‚_t A|Â²/Z_det).
    This directly extracts wave energy, not just reflects it."""
    mask = np.zeros((nx, ny), dtype=np.float32)
    if observe_slit:
        damping_strength = 0.85  # strong Ohmic load (real detector)
        for dx in range(-4, 5):
            for dy in range(-slit_w, slit_w):
                xi = wall_x + dx
                yi = slit_2 + dy
                if 0 <= xi < nx and 0 <= yi < ny:
                    r = np.sqrt(dx**2 + (dy / slit_w * 3)**2) / 3
                    if r < 1.0:
                        mask[xi, yi] = damping_strength * (1.0 - r)**2
    return jnp.array(mask)


@jit
def _fdtd_step(P, Vx, Vy, wall_mask, damping, obs_damping,
               dt, dx, source_x_start, source_y, freq, t, wall_x):
    """
    One FDTD timestep of the 2D acoustic solver (JIT-compiled).

    Physics: the vacuum is a 2D acoustic medium with uniform cÂ²=1.
    The observer is an Ohmic load that thermalizes wave energy at slit 2
    (Joule friction: W âˆ |âˆ‚_t A|Â²/Z_det).
    """
    # Update velocities
    Vx = Vx.at[:-1, :].add(-dt * (P[1:, :] - P[:-1, :]) / dx)
    Vy = Vy.at[:, :-1].add(-dt * (P[:, 1:] - P[:, :-1]) / dx)

    # Hard wall
    Vx = jnp.where(wall_mask, 0.0, Vx)
    Vy = jnp.where(wall_mask, 0.0, Vy)

    # Update pressure (uniform cÂ²=1 everywhere)
    div_v = (Vx[1:-1, 1:-1] - Vx[:-2, 1:-1]) / dx + (Vy[1:-1, 1:-1] - Vy[1:-1, :-2]) / dx
    P = P.at[1:-1, 1:-1].add(-dt * div_v)

    # Ohmic observer: thermalize ALL field components at detector.
    # A real resistive load absorbs both voltage (P) and current (V).
    P = P * (1.0 - obs_damping)
    Vx = Vx * (1.0 - obs_damping)
    Vy = Vy * (1.0 - obs_damping)

    # Sponge ABC
    P = P * damping
    Vx = Vx * damping
    Vy = Vy * damping

    # Source: moving particle emitting its wake as it travels
    # The particle passes through Slit 1; source tapers off past the wall
    source_x = jnp.int32(source_x_start + t * 0.22)
    in_range = (source_x > 0) & (source_x < wall_x + 40)
    taper = jnp.clip(1.0 - (source_x - wall_x) / 40.0, 0.0, 1.0)
    amp = jnp.sin(2 * jnp.pi * freq * t) * 2.5 * in_range * taper
    P = P.at[source_x, source_y].add(amp)
    P = P.at[source_x, source_y - 1].add(amp * 0.3)
    P = P.at[source_x, source_y + 1].add(amp * 0.3)
    P = P.at[source_x, source_y - 2].add(amp * 0.15)
    P = P.at[source_x, source_y + 2].add(amp * 0.15)

    return P, Vx, Vy


def run_fdtd_jax(nx=800, ny=500, steps=2500, observe_slit=False):
    """Run the full 2D FDTD simulation on GPU via JAX."""
    dt = 0.45
    dx = 1.0

    sponge = 50
    wall_x = int(nx * 0.35)
    wall_t = 4
    slit_w = 14
    slit_sep = 90
    slit_1 = ny // 2 - slit_sep // 2
    slit_2 = ny // 2 + slit_sep // 2
    freq = 0.06
    source_x_start = 60
    source_y = slit_1  # Particle aimed at Slit 1 (AVE: particle through ONE slit)
    particle_speed = 0.22  # nodes per timestep

    # Build static geometry (CPU, once)
    damping = _build_sponge(nx, ny, sponge)
    wall_mask = _build_wall(nx, ny, wall_x, wall_t, slit_w, slit_1, slit_2)

    # Build Ohmic observer (AVE first principles: Joule thermalization)
    obs_damping = _build_obs_damping(nx, ny, wall_x, slit_2, slit_w, observe_slit)

    # Initialize fields on GPU
    P = jnp.zeros((nx, ny))
    Vx = jnp.zeros((nx, ny))
    Vy = jnp.zeros((nx, ny))
    intensity = jnp.zeros((nx, ny))

    integrate_start = steps // 3

    # Time integration (each step is JIT-compiled)
    for t_step in range(steps):
        P, Vx, Vy = _fdtd_step(
            P, Vx, Vy, wall_mask, damping, obs_damping,
            dt, dx, source_x_start, source_y, freq, float(t_step),
            wall_x,
        )

        # Integrate intensity after transient
        if t_step > integrate_start:
            intensity = intensity + P ** 2

    # Normalize
    intensity = intensity / (jnp.max(intensity) + 1e-30)

    return np.array(intensity), wall_mask, slit_1, slit_2, source_x_start, source_y


def main():
    print("=" * 70)
    print("  Double Slit: Standing Wave Heatmap â€” JAX GPU-Accelerated")
    print("=" * 70)

    import time
    steps = 2500

    # Run WITHOUT observer
    print("\n  Running FDTD (no observer) on GPU...", flush=True)
    t0 = time.time()
    intensity_no_obs, wall_mask_arr, slit_1, slit_2, source_x, source_y = \
        run_fdtd_jax(nx=800, ny=500, steps=steps, observe_slit=False)
    print(f"  Done in {time.time()-t0:.1f}s")

    # Run WITH observer at slit 2
    print("  Running FDTD (observer at slit 2) on GPU...", flush=True)
    t0 = time.time()
    intensity_obs, _, _, _, _, _ = \
        run_fdtd_jax(nx=800, ny=500, steps=steps, observe_slit=True)
    print(f"  Done in {time.time()-t0:.1f}s")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Generate comparison plot (identical to numpy version)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    wall_mask_np = np.array(wall_mask_arr)
    NX, NY = 800, 500

    fig = plt.figure(figsize=(20, 10))
    fig.patch.set_facecolor('#050510')
    gs = GridSpec(1, 3, figure=fig, width_ratios=[1, 1, 0.08], wspace=0.12)

    for idx, (intensity, title, label) in enumerate([
        (intensity_no_obs,
         'No Observer: Coherent Wake Interference',
         'Particle passes through SLIT 1\nWake passes through BOTH slits\nâ†’ coherent interference fringes'),
        (intensity_obs,
         'Observer at Slit 2: Wake Decoherence',
         'Particle still passes through Slit 1\nDetector at Slit 2 thermalizes wake\nâ†’ phase coherence destroyed'),
    ]):
        ax = fig.add_subplot(gs[0, idx])
        ax.set_facecolor('#050510')

        im = ax.imshow(intensity.T, cmap='hot', origin='lower',
                       extent=[0, NX, 0, NY],
                       vmin=0, vmax=0.25, aspect='auto')

        wall_display = np.ma.masked_where(~wall_mask_np, np.ones_like(wall_mask_np, dtype=float))
        ax.imshow(wall_display.T, cmap='Greys', alpha=0.9, origin='lower',
                  extent=[0, NX, 0, NY], aspect='auto')

        if idx == 1:
            wall_x = int(NX * 0.35)
            ax.plot(wall_x, slit_2, 'o', color='#00ff00',
                    markersize=12, markeredgecolor='white', markeredgewidth=2,
                    zorder=10)
            ax.annotate('OBSERVER', xy=(wall_x, slit_2),
                        xytext=(wall_x - 80, slit_2 + 60),
                        fontsize=11, color='#00ff00', fontweight='bold',
                        arrowprops=dict(arrowstyle='->', color='#00ff00', lw=2))

        ax.annotate('Slit 1', xy=(int(NX * 0.35) + 5, slit_1),
                    fontsize=9, color='white', alpha=0.7)
        ax.annotate('Slit 2', xy=(int(NX * 0.35) + 5, slit_2),
                    fontsize=9, color='white', alpha=0.7)

        # Mark particle trajectory line (aimed at Slit 1)
        ax.plot(source_x, slit_1, '*', color='cyan', markersize=15, zorder=10,
                label='Particle start')
        # Draw trajectory arrow through Slit 1
        ax.annotate('', xy=(int(NX * 0.55), slit_1),
                    xytext=(source_x, slit_1),
                    arrowprops=dict(arrowstyle='->', color='cyan', lw=2, ls='--'))

        levels = np.linspace(0.05, 0.20, 6)
        ax.contour(intensity.T, levels=levels, colors='#ff00aa',
                   alpha=0.25, linewidths=0.5,
                   extent=[0, NX, 0, NY])

        ax.set_title(title, color='white', fontsize=14, fontweight='bold', pad=10)
        ax.set_xlabel('Propagation Axis (nodes)', color='white', fontsize=11)
        if idx == 0:
            ax.set_ylabel('Transverse Axis (nodes)', color='white', fontsize=11)
        ax.tick_params(colors='white')

        props = dict(boxstyle='round', facecolor='#111122', alpha=0.9,
                     edgecolor='#ff00aa' if idx == 0 else '#00ff00')
        ax.text(0.02, 0.02, label, transform=ax.transAxes,
                fontsize=10, color='white', verticalalignment='bottom',
                bbox=props)

        for spine in ax.spines.values():
            spine.set_color('#333')

    cax = fig.add_subplot(gs[0, 2])
    cbar = plt.colorbar(im, cax=cax)
    cbar.set_label('Time-Averaged Wave Energy $\\langle |\\Psi|^2 \\rangle$',
                   color='white', fontsize=12)
    cbar.ax.tick_params(colors='white')

    fig.suptitle(
        r"AVE Double Slit: Particle Through Slit 1, Wake Through Both (JAX GPU)",
        color='white', fontsize=18, fontweight='bold', y=0.98)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Transverse intensity cross-section
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fig2 = plt.figure(figsize=(14, 6))
    fig2.patch.set_facecolor('#050510')
    ax_cross = fig2.add_subplot(111)
    ax_cross.set_facecolor('#0a0a0a')

    x_cross = int(NX * 0.85)
    y = np.arange(NY)

    cross_no_obs = intensity_no_obs[x_cross, :]
    cross_obs = intensity_obs[x_cross, :]

    from scipy.ndimage import gaussian_filter1d
    cross_no_obs_s = gaussian_filter1d(cross_no_obs, sigma=3)
    cross_obs_s = gaussian_filter1d(cross_obs, sigma=3)

    ax_cross.fill_between(y, cross_no_obs_s, alpha=0.3, color='#ff6b6b')
    ax_cross.plot(y, cross_no_obs_s, color='#ff6b6b', linewidth=2,
                  label='No Observer (coherent interference)')
    ax_cross.fill_between(y, cross_obs_s, alpha=0.3, color='#00ffcc')
    ax_cross.plot(y, cross_obs_s, color='#00ffcc', linewidth=2,
                  label='Observer at Slit 2 (decoherence)')

    ax_cross.set_xlabel('Transverse Position (nodes)', color='white', fontsize=12)
    ax_cross.set_ylabel('$\\langle |\\Psi|^2 \\rangle$ (normalized)', color='white', fontsize=12)
    ax_cross.set_title(
        f'Far-Field Intensity Cross-Section at x = {x_cross} nodes',
        color='white', fontsize=14, fontweight='bold')
    ax_cross.legend(fontsize=12, facecolor='#1a1a1a', edgecolor='#333',
                    labelcolor='white', loc='upper right')
    ax_cross.tick_params(colors='white')
    ax_cross.grid(True, alpha=0.1, color='white')
    for spine in ax_cross.spines.values():
        spine.set_color('#333')

    # Save both
    out1 = os.path.join(OUT_DIR, 'double_slit_heatmap_comparison.png')
    fig.savefig(out1, dpi=200, bbox_inches='tight', facecolor=fig.get_facecolor())
    plt.close(fig)
    print(f"\n  ğŸ“Š Heatmap saved: {out1}")

    out2 = os.path.join(OUT_DIR, 'double_slit_cross_section.png')
    fig2.savefig(out2, dpi=200, bbox_inches='tight', facecolor=fig2.get_facecolor())
    plt.close(fig2)
    print(f"  ğŸ“Š Cross-section saved: {out2}")

    # Summary
    print(f"\n  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"  AVE INTERPRETATION (Correct Physics)")
    print(f"  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"  The PARTICLE passes through SLIT 1 (one slit only).")
    print(f"  The transverse WAKE radiates from the particle's trajectory")
    print(f"  and passes through BOTH slits.")
    print(f"")
    print(f"  WITHOUT observer: the wake through both slits interferes")
    print(f"  coherently â†’ standing wave fringes on the far side.")
    print(f"  The particle is steered by âˆ‡|Î¨|Â² into the fringe troughs.")
    print(f"")
    print(f"  WITH observer: a physical impedance perturbation (detector)")
    print(f"  at Slit 2 thermalizes the wake's phase energy (Joule friction),")
    print(f"  destroying coherence â†’ single-slit envelope.")
    print(f"")
    print(f"  'Wavefunction collapse' = classical structural decoherence.")
    print(f"  There is no mystery.")
    print(f"  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")


if __name__ == "__main__":
    main()
